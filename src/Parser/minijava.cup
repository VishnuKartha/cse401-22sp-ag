/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp, ...
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;

/* operators */
terminal PLUS, MINUS, TIMES, AND;
terminal BECOMES;
terminal NOT;
terminal PERIOD;
terminal LESS_THAN;

/* delimiters */
terminal LPAREN, RPAREN, SEMICOLON, COMMA;
terminal LBRACKET, RBRACKET;
terminal LBRACE, RBRACE;

/* identifiers */
terminal String IDENTIFIER;

/* letters */
terminal Character LETTER;

/* types */
terminal String INT;
terminal String BOOLEAN;
terminal Integer INTEGER_LITERAL;


/* keywords */
terminal String TRUE, FALSE;
terminal String CLASS;
terminal String PUBLIC, STATIC, VOID, MAIN;
terminal String NEW;
terminal String IF, ELSE, WHILE;
terminal String SOUT;
terminal String THIS;
terminal String RETURN;
terminal String EXTENDS;
terminal String LENGTH;
terminal String STRING;

/* Nonterminals (constructed by parser): */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Exp Exp;
nonterminal ExpList ExpList;

nonterminal Identifier Identifier;


/* Precedence declarations: */

precedence left PLUS;


/* Productions: */

Program ::= MainClass:mc ClassDeclList:cd
        {: RESULT = new Program(mc, cd, mcxleft); :};

MainClass  ::= CLASS Identifier:id1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET
              	      RBRACKET Identifier:id2 RPAREN LBRACE Statement:s RBRACE RBRACE
                {: RESULT =  new MainClass(id1, id2, s, id1xleft); :};


Statement ::= LBRACE  StatementList:s RBRACE
                {: RESULT = new Block(s, sleft); :}
            |  IF LPAREN Expression:e RPAREN Statement:s1 ELSE Statement:s2
                                {: RESULT = new If(expr, s1, s2,exleft); :}
//     IDK HOW TO ADD PRINT STATEMENT       |
            | WHILE LPAREN Expression:e RPAREN Statement:s
                 {: RESULT = new While(expr, s, exleft); :}
	        | Identifier:i BECOMES Expression:e SEMICOLON
                              {: RESULT = new Assign(id, expr, ixleft); :}
                          | WHILE:w LPAREN Expression:expr RPAREN Statement:s
            |  Identifier:i LBRACKET Expression:e1 RBRACKET BECOMES
              			 Expression:expr2 SEMICOLON
                                         {: RESULT = new ArrayAssign(id, expr1, expr2, ixleft); :};

StatementList ::= NonEmptySL:sl
                    {: RESULT = sl; :}
		| /* epsilon */
                    {: RESULT = new StatementList(0); :};

Exp    ::= Exp: e1 AND Exp: e2
            {: RESULT = new And(e1, e2, e1xleft); :}
        | Exp:e1 LESS_THAN Exp:e2
            {: RESULT = new LessThan(e1, e2, e1xleft); :}
        | Exp:e1 PLUS Exp:e2
                    {: RESULT = new Plus(e1,  e2, e1xleft); :}
        | Exp:e1 MINUS Exp:e2
                    {: RESULT = new Minus(e1, e2, e1xleft); :}
        | Exp:e1 TIMES Exp:e2
                    {: RESULT = new Times(e1, e2, e1xleft); :}
        | Exp:e1 LBRACKET Exp:e2 RBRACKET
            {: RESULT = new ArrayLookup(e1, e2, e1xleft); :}
        | Exp:e1 PERIOD LENGTH
            {: RESULT = new ArrayLength(e1, e1xleft); :}
        | Exp:e1 PERIOD Identifier:id LPAREN ExpList:expl RBRACKET
            {: RESULT = new Call(e1, id, expl,e1xleft); :}
        | Exp:e1 PERIOD Identifier:id LPAREN RBRACKET
            {: RESULT = new Call(e1, id,new ExpList(e1xleft),e1xleft); :}
        | INTEGER_LITERAL: i
            {: RESULT = new IntegerLiteral(i, ixleft) ; :}
        | TRUE: t
            {: RESULT = new True(txleft) ; :}
        | FALSE: f
            {: RESULT = new False(fxleft) ; :}
        | Identifier: i
            {: RESULT = new IdentifierExp(i,ixleft) ; :}
        | THIS: t
            {: RESULT = new This(txleft) ; :}
        | NEW INT LBRACKET Exp:e RBRACKET
            {: RESULT = new NewArray(e, exleft); :}
        | NEW Identifier:i LPAREN RPAREN
            {: RESULT = new NewObject(i, exleft); :}
        | NOT Exp:e
            {: RESULT = new Not(i, exleft); :}
        | LPAREN Exp:e RPAREN
            {: RESULT = new Exp(exleft); :};
ExpList ::= Exp: e
          {: RESULT = new ExpList(e1xleft);:}
        | ExpList: exp_list COMMA Exp: e
         {: exp_list.add(e);
            RESULT = exp_list; :};

Identifier  ::= IDENTIFIER:id
                {: RESULT = new Identifier(id, idxleft); :};


